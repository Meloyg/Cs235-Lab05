<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<title>Moodle Quiz XHTML Export</title>
<style type="text/css">
body {
     font-family: verdana, helvetica, sans-serif;
     background-color: #fff;
     color: #000;
 }
 
 .question {
     border: 1px solid #ddd;
     margin: 5px;
     padding: 3px;
 }
 
 .question h3 {
     font-weight: normal;
     font-size: 125%;
 }
 
 .question ul {
     list-style-type: none;
 }
</style>
</head>
<body>
<form action="...REPLACE ME..." method="post">



<!-- question: 267019  name: 2020S2LabWeek9 SQLLite 01 get info about database -->
<div class="question">
<h3>2020S2LabWeek9 SQLLite 01 get info about database</h3>
<p class="questiontext"><p>In this lab we will work with an SQLite database which is stored as a file. You can download the database file from <a href="https://coderunner.auckland.ac.nz/moodle/pluginfile.php/30229/question/questiontext/preview/30229/qformat_xhtml/267019/267019/chinook.db">here</a>. Our aim of this lab is to use Python and its built in support for the interaction with a simplified SQLite relational database, which however features similar functionality as "full-grown" relational databases like MySQL or Oracle. For the moment, we will work on writing SQL statements to interact with this database and use Python as a programming interface that enables the writing of SQL statements. See lecture 15 for more details on SQL statements!</p><p><br></p><p>In this exercise, your task is to inspect the given database, which is called 'chinook.db', as you can see from the testing code below in the example. We first would like to know how the logical schema of the database looks like, in order to work with it later in terms of reading from and writing to the database. Please also note that a software tool like <a href="https://sqlitebrowser.org/">"DB Browser for SQLite"</a> can be used to inspect and modify an SQLite database file like 'chinook.db'. <br></p><p><br></p><p>To solve this exercise you have to write a function <code>get_table_information_from_database(database_filename)</code>, which returns a dictionary that has all the available table names as its keys, and a list of the column names for the respective table as its values. The column names are the second entries in the record returned from the "PRAGMA table_info" SQL statement given below.<br></p><p>Regarding the structure of this code, you have to make sure that the Python <code>sqlite3</code> package is first imported. Using the connect method from this package, a database connection can be opened. This connection uses the concept of a cursor object to send SQL statements to the database in the form of strings. In case the SQL string represents a query, the cursor.execute method returns a result containing the result of this query. This result is a list and can be inspected here in this question for the logical schema information.</p><p>The necessary SQL statements you need are:</p><ul><li>"SELECT name FROM sqlite_master WHERE type='table'"</li><li>and for each table, identified by a string 'table_name': "PRAGMA table_info('table_name')"<br></li></ul><p>Attention: Please ignore table names that start with the substring "sqlite" from the query result, since these are internal tables, which in general should not be used by an application!</p><p>Don't forget to close the database connection after you are finished accessing the database!<br></p><p>Please have a look at the examples in the lecture slides for lecture 15 to see examples of SQLite being used. Additionally, you may want to look up more information on the web page for Python's SQLite API <a href="https://docs.python.org/3.7/library/sqlite3.html#">here</a>. SQL statements are simply strings, which can be concatenated using string literals and string variables.<br></p><p>Note: As always, it is a good idea to work on this example using your favourite IDE first (download the database file), before you enter it into coderunner. This way you can more easily debug your code!<br></p><p></p></p>
<!-- export of coderunner type is not supported  -->
</div>



<!-- question: 267018  name: 2020S2LabWeek9 SQLLite 02 select from any table -->
<div class="question">
<h3>2020S2LabWeek9 SQLLite 02 select from any table</h3>
<p class="questiontext"><p>Now that we know which tables our database contains, and how the columns of each table are called, we will proceed with a central functionality of the SQL Query Language (QL), the SELECT statement for accessing actual data (also called records, rows,
    or tuples) from the database. Please find below a diagram that shows the tables of the chinook database, and all their columns, datatypes and associations. The chinook example as well as this diagram were taken from the SQLite tutorial <a href="https://www.sqlitetutorial.net/sqlite-sample-database/">here</a>.<br></p>
<p><img src="https://coderunner.auckland.ac.nz/moodle/pluginfile.php/30229/question/questiontext/preview/30229/qformat_xhtml/267018/267018/ChinookDiagram.jpg" alt="Chinook Database Diagram" class="img-responsive atto_image_button_text-bottom" width="800" height="402"><br></p>
<p>Your task in this exercise is to write a function <code>perform_query_for_whole_table(database_filename, table_name)</code>, which takes a string indicating which table we want to access data from as its input (besides the filename of the database), and returns the result of the SQL query as a list. Note that we want to access ALL data from a given table to form our result! You can assume that the parameter&nbsp;<code>table_name</code> refers to a table that exists in the database!<br></p><p>Please have a look at the testing code to see how the list of results is then printed for its data. Your task however is solely to write the query code and return the result of the query in the function.<br></p>Don't forget to close the database connection after you are finished accessing the database!<br><p></p></p>
<!-- export of coderunner type is not supported  -->
</div>



<!-- question: 267020  name: 2020S2LabWeek9 SQLLite 03 select where order by -->
<div class="question">
<h3>2020S2LabWeek9 SQLLite 03 select where order by</h3>
<p class="questiontext"><p>In this exercise we will start doing more sophisticated queries. Imagine someone is interested in all "Best of" and "Greatest Hits" albums contained in the database. <br></p><p>Your task in this exercise is to write a function called <code>get_best_of_albums(database_filename, column_name_for_ordering)</code>, which opens the database and formulates a SELECT statement that gets <b>all</b> data from the "albums" table, which have the&nbsp; substring "Greatest Hits" or "Best Of" anywhere in its "Title" column. We want to present these results in an ordered manner, where the column name for the ordering is passed as a parameter to this function. The result of the function is again the result of the query statement, i.e. a list of database records.</p><p>You may not assume that the provided parameter&nbsp;<code>column_name_for_ordering</code> contains a column name that exists in the database table "albums". Therefore, you have to check first, if this is the case. Here the function written in Question 01 comes in handy, you can copy it and use it here. If the column name is not present as a column in "albums", you have to return and empty list and write an error message as shown in the examples. <br></p><p>Hint: The use of "LIKE" will come in handy in this exercise.<br></p><p>Don't forget to close the database connection after you have finished accessing it!<br></p><p></p></p>
<!-- export of coderunner type is not supported  -->
</div>



<!-- question: 267021  name: 2020S2LabWeek9 SQLLite 04 select with inner join -->
<div class="question">
<h3>2020S2LabWeek9 SQLLite 04 select with inner join</h3>
<p class="questiontext"><p></p><p>Now let's repeat the task of Question 03, but improve the query result by not only providing information from the "albums" table, where the third column showed an ArtistId as an integer, but instead of the ArtistId received from the "albums" table we would like to include information from the "artists" table as well. To do that, we will require an SQL INNER JOIN.<br></p><p>Your task in this exercise is to write a function called <code>get_best_of_albums_include_artists(database_filename)</code>,
 which opens the database and formulates a SELECT statement that gets the "AlbumId" and "Title" data from the "albums" table as well as the associated artists "Name" column from the "artists" table, which have the&nbsp; substring "Greatest 
Hits" or "Best Of" anywhere in the "Title" column of the "albums" table. The result should be presented ordered by the artists name. The result of the 
function is again the result of the query statement, i.e. a list of 
database records.</p><p>Study how an INNER JOIN works using the lecture slides and if necessary the tutorials and documentations indicated in previous questions.<br></p>Don't forget to close the database connection after you have finished accessing it!<p></p><p></p></p>
<!-- export of coderunner type is not supported  -->
</div>



<!-- question: 267022  name: 2020S2LabWeek9 SQLLite 05 select with inner join and count -->
<div class="question">
<h3>2020S2LabWeek9 SQLLite 05 select with inner join and count</h3>
<p class="questiontext"><p><p>Your task in this exercise is to write a function called <code>get_all_artists_with_at_least_n_albums</code><code>(database_filename, n)</code>,
 which formulates a SELECT statement that returns artist ID, artist name and album count for all artists in the database which have <code>n</code> or more albums stored in the database. This statement requires again an INNER JOIN, and uses the COUNT statement to count albums. You should group the result by artist name and order the result by number of albums (descending) first, and - in case artists have the same number of albums - artist name (ascending) second. See also the example below.</p><p>The result 
of the 
function is a list of 
database records.<br></p>Don't forget to close the database connection after you have finished accessing it!<br></p><p></p></p>
<!-- export of coderunner type is not supported  -->
</div>



<!-- question: 267023  name: 2020S2LabWeek9 SQLLite 06 select playlist -->
<div class="question">
<h3>2020S2LabWeek9 SQLLite 06 select playlist</h3>
<p class="questiontext"><p></p><p>Your task in this exercise is to write a function called <code>get_playlist_tracks</code><code>(database_filename, which_playlist)</code>,
 which formulates a SELECT statement that returns track name, album title, genre name, artist name and track composer for all tracks in the database which are associated with a given playlist. This statement requires several nested INNER JOINs to pull together data from the "tracks", "albums", "genres", "artists", and "playlists" table. The default ordering of tracks should be used. The result 
of the 
function is a list of 
database records. The parameter&nbsp;<code>which_playlist</code> specifies a playlist in the database. You first have to check if the playlist is contained in the "playlists" table, if not an error message as indicated in the examples has to be printed and an empty list has to be returned. <br></p><p>Don't forget to close the database connection after you have finished accessing it!</p><p></p><br><p></p></p>
<!-- export of coderunner type is not supported  -->
</div>



<!-- question: 267024  name: 2020S2LabWeek9 SQLLite 07 insert new association table -->
<div class="question">
<h3>2020S2LabWeek9 SQLLite 07 insert new association table</h3>
<p class="questiontext"><p>Finally, in this exercise we will create a new table and insert values for the new table into our chinook database. From the database schema, you can see that the database not only contains media data, but also data on customers and employees of an associated
    company.
</p>
<p>In this exercise, we will create an association table connecting data from the already existing "employees" table with data from the "tracks" table. This will allow us to store favourite songs of employees in the database. Your task is to write a function
    <code>save_favourite_songs(destination_database, employee_first_name, employee_last_name, artist)</code>, which implements the functionality that all tracks in the database from artist <code>artist</code> are stored as favourite songs of the given
    employee (identified by first and last name). <br></p>
<p>This exercise consists of several steps:</p>
<ul>
    <li>First use a "CREATE TABLE" SQL DDL statement to create a new table called "employee_favourite_tracks". This table has two columns, "EmployeeId" and "TrackId". Both columns have to have a value, and combined they are a PRIMARY KEY. "EmployeeID" further
        is a FOREIGN KEY referencing the EmployeeID in the "employees" table, and "TrackId" is a FOREIGN KEY referencing the TrackId in the "tracks" table. After execution of the SQL statement, you need to commit this change to the database, to become
        effective.
    </li>
    <li>Then, generate and execute a SELECT statement to receive the EmployeeId from the "employees" table, using the given strings for first and last name in the query. If the Employee can not be found in the database, an error message is displayed and the
        function returns.</li>
    <li>Then, generate and execute a SELECT statement to receive all tracks of the given artist contained in the database, making use of INNER JOIN again.</li>
    <li>Finally, insert all tracks of the given artist into the newly created table using the "INSERT INTO table VALUES()" SQL statement. After collecting and executing all the insert statements, you need to perform a commit on the database.</li>
</ul>
<p>We will assess the database by a Query of the favourite songs of the employee in the testing code.</p>
<p>Attention: Please note that in this exercise, we are not passing a database filename into the function, but already a database connection object. The reason for that is, that Coderunner does not allow us to modify the 'chinook.db' database file. Therefore,
    we are copying the whole file from an SQLite file database into an SQLite in-memory database first. This is performed in the function <code>copy_file_db_to_memory_db</code>, which is part of our internal testing code and which returns the connection object to the in-memory database as can be seen
    in the code below (you may use this code if you work in your own IDE on this question):<br></p>

<pre>from io import StringIO<br></pre>
<pre>def copy_file_db_to_memory_db(database_filename):</pre>
<pre>&nbsp;&nbsp;&nbsp; # Read database to tempfile</pre>
<pre>&nbsp;&nbsp;&nbsp; con = sqlite3.connect(database_filename)</pre>
<pre>&nbsp;&nbsp;&nbsp; tempfile = StringIO()</pre>
<pre>&nbsp;&nbsp;&nbsp; for line in con.iterdump():</pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempfile.write('%s\n' % line)</pre>
<pre>&nbsp;&nbsp;&nbsp; con.close()</pre>
<p><br></p>
<pre>&nbsp;&nbsp;&nbsp; tempfile.seek(0)</pre>
<pre>&nbsp;&nbsp;&nbsp; mem_db = sqlite3.connect(":memory:")</pre>
<pre>&nbsp;&nbsp;&nbsp; mem_db.cursor().executescript(tempfile.read())</pre>
<pre>&nbsp;&nbsp;&nbsp; mem_db.commit()</pre>
<pre>&nbsp;&nbsp;&nbsp; return mem_db</pre>
<p></p></p>
<!-- export of coderunner type is not supported  -->
</div>



<p class="submit">
  <input type="submit" />
</p>
</form>
</body>
</html>
